// Copyright 2019 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Encapsulates logic of finding roots in native stack frames
// by walking the callstack using metadata from the compiler.
component NativeStackScanner {
	def D = RiGc.D;
	new() {
        	RiGc.scanStack = scanStack;
        }
	// scan the stack, walking frames up to the main method
	def scanStack(i: Pointer, s: Pointer) {
		var ip = i, sp = s;
		while (true) {
			var frameWords = 0;
			if (RiGc.debug) {
				D.puts(RiGc.CTRL_DEFAULT)
				 .puts("\nscanStack @ ip = ").putp(ip).puts(" +")
				 .puti(ip - CiRuntime.CODE_START)
				 .puts(", sp = ").putp(sp).putc('\n');
				D.puts(RiGc.CTRL_CYAN);
				frameWords = NativeStackPrinter.printLoc(ip); // double-check frame size in debug mode
				D.puts(RiGc.CTRL_DEFAULT);
			}
			var stackmapEntry = RiTables.exactMatch(RiTables.searchTable(CiRuntime.GC_STACKMAP_PAGES,
                        								CiRuntime.GC_STACKMAP_TABLE, ip));
			if (stackmapEntry == Pointer.NULL) {
				if (RiGc.debug) {
					D.puts("(no stackmap information)\n");
					if (frameWords == 0) return;
					var t = RiOs.callerFrame(ip, sp, frameWords);
					ip = t.0; sp = t.1;
					continue;
				}
				return;
			}
			var frameSize = scanStackFrame(sp, stackmapEntry);
			if (RiGc.debug && frameSize != frameWords * RiGc.REF_SIZE) {
				D.puts("\n\n!GcError: mismatch between source frame size ")
				 .puti(frameWords * RiGc.REF_SIZE)
				 .puts(" and stackmap size of ")
				 .puti(frameSize)
				 .ln();
				RiOs.exit(255);
			}
			var t = RiOs.callerFrame(ip, sp, frameSize / RiGc.REF_SIZE);
			ip = t.0; sp = t.1;
		}
	}
	// scan a single stack frame
	def scanStackFrame(sp: Pointer, stackmapEntry: Pointer) -> int {
		var stackMap = stackmapEntry.load<int>() >>> RiTables.PAGE_SHIFT;
		if ((stackMap & 0x80000) != 0) {
			// extended entry
			var vmap_p = CiRuntime.GC_EXTMAPS + (RiGc.INT_SIZE * (stackMap & 0x7FFFF));
			return RiGc.scanExtMap(vmap_p, sp);
		} else {
			// normal entry
			return RiGc.scanRefMap(stackMap, sp);
		}
	}
}
